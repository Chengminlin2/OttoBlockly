<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OTTO Biped 積木流程（Play 才執行）</title>
<style>
  body{ font-family: Arial, sans-serif; background:#f6f7fb; margin:0; padding:18px; text-align:center; }
  .panel{
    max-width:980px; margin:12px auto; background:#fff; border-radius:14px;
    padding:14px; box-shadow:0 2px 12px rgba(0,0,0,.06); text-align:left;
  }
  .row{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:flex-start; }
  button{
    border:none; border-radius:10px; padding:10px 14px; cursor:pointer;
    background:#4CAF50; color:#fff; font-size:14px;
  }
  button.red{ background:#d9534f; }
  button.blue{ background:#0275d8; }
  button.gray{ background:#6c757d; }
  button:disabled{ opacity:.5; cursor:not-allowed; }
  select, input[type="number"], input[type="text"]{
    padding:8px 10px; border:1px solid #ddd; border-radius:10px; font-size:14px;
  }
  input[type="range"]{ width:220px; }
  .status{ font-size:14px; color:#333; }
  .hint{ font-size:12px; color:#666; line-height:1.5; }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

  /* 積木清單 */
  #blocks{ list-style:none; padding:0; margin:10px 0 0; }
  .block{
    display:flex; align-items:center; gap:10px;
    background:#f3f5ff; border:1px solid #e2e6ff;
    border-radius:12px; padding:10px 10px; margin:8px 0;
    user-select:none;
  }
  .handle{
    width:30px; height:30px; border-radius:8px; background:#e7e9ff;
    display:flex; align-items:center; justify-content:center; font-weight:bold; color:#334;
    cursor:grab;
  }
  .block.dragging{ opacity:.5; }
  .block .meta{ flex:1; }
  .block .title{ font-weight:700; color:#223; margin-bottom:2px; }
  .block .desc{ font-size:12px; color:#445; }
  .block .actions{ display:flex; gap:8px; }
  .block .actions button{ padding:8px 10px; border-radius:10px; font-size:13px; }

  /* Log */
  .log{
    background:#111; color:#eee; border-radius:10px; padding:10px 12px;
    font-size:12px; height:190px; overflow:auto; white-space:pre-wrap;
  }

  .badge{ display:inline-block; padding:2px 8px; border-radius:999px; background:#eee; font-size:12px; }
</style>
</head>

<body>
  <h2>OTTO Biped 功能積木（拖拉排序，按 Play 才執行）</h2>

  <!-- 連線與速度 -->
  <div class="panel">
    <div class="row">
      <button id="connectBle" class="blue">連線 / Connect</button>
      <button id="disconnectBle" class="red" disabled>中斷 / Disconnect</button>
      <span id="status" class="status">尚未連線</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <span class="badge">速度</span>
      <input id="speed" type="range" min="0" max="5" step="1" value="2" />
      <span id="speedLabel" class="mono">2</span>
      <span class="hint">（移動/超音波指令會用最後一碼當速度，例如 <span class="mono">forward2</span>）</span>
    </div>

    <div class="hint" style="margin-top:8px;">
      BLE Service：<span class="mono">0000ffe0-0000-1000-8000-00805f9b34fb</span>，
      Characteristic：<span class="mono">0000ffe1-0000-1000-8000-00805f9b34fb</span><br/>
      你 Arduino 端需支援：<span class="mono">forward/backward/left/right/stop</span>、
      <span class="mono">ultrasound</span>、
      <span class="mono">autoavoid_on/off</span>、
      <span class="mono">us_stream_on/off</span>、
      以及表情：<span class="mono">happy/sad/...</span>
    </div>
  </div>

  <!-- 新增積木 -->
  <div class="panel">
    <div class="row">
      <select id="blockType">
        <option value="move">移動（前進/後退/左/右/停）</option>
        <option value="gesture">表情/動作（happy、wave…）</option>
        <option value="ultra_once">超音波：量測一次（ultrasound）</option>
        <option value="autoavoid_on">超音波：自動避障 ON</option>
        <option value="autoavoid_off">超音波：自動避障 OFF</option>
        <option value="stream_on">超音波：距離串流 ON</option>
        <option value="stream_off">超音波：距離串流 OFF</option>
        <option value="set_speed">設定速度（0~5）</option>
        <option value="wait">等待（秒）</option>
      </select>

      <span id="optMove" class="row" style="gap:8px;">
        <select id="moveCmd">
          <option value="forward">前進 forward</option>
          <option value="backward">後退 backward</option>
          <option value="left">左轉 left</option>
          <option value="right">右轉 right</option>
          <option value="stop">停止 stop</option>
        </select>
        <input id="moveMs" type="number" min="0" step="100" value="800" style="width:110px;" />
        <span class="hint">毫秒（0 代表不等待）</span>
      </span>

      <span id="optGesture" class="row" style="gap:8px; display:none;">
        <input id="gestureCmd" type="text" value="happy" style="width:180px;" />
        <span class="hint">例如 happy / sad / wave / victory / fart</span>
      </span>

      <span id="optSetSpeed" class="row" style="gap:8px; display:none;">
        <input id="setSpeedVal" type="number" min="0" max="5" step="1" value="2" style="width:90px;" />
        <span class="hint">0~5</span>
      </span>

      <span id="optWait" class="row" style="gap:8px; display:none;">
        <input id="waitSec" type="number" min="0" step="0.5" value="1" style="width:90px;" />
        <span class="hint">秒</span>
      </span>

      <button id="addBlock">加入積木</button>
      <button id="clearBlocks" class="gray">清空</button>
    </div>

    <div class="hint" style="margin-top:10px;">
      操作：拖拉左側把手排序 → 按 Play 才會執行。執行中可按 Stop 中止。<br/>
      小技巧：走路常用「前進(800ms) → 停止(200ms) → 前進(800ms)」。
    </div>

    <ul id="blocks"></ul>

    <div class="row" style="margin-top:10px;">
      <button id="play" class="blue" disabled>▶ Play</button>
      <button id="stopRun" class="red" disabled>■ Stop</button>
      <span class="status" id="runnerStatus">流程：待命</span>
    </div>
  </div>

  <!-- Log -->
  <div class="panel">
    <div class="row" style="justify-content:space-between;">
      <div class="status">Log</div>
      <button id="clearLog" class="gray">清除 Log</button>
    </div>
    <div id="log" class="log" aria-label="log"></div>
  </div>

<script>
/* =============================
   BLE（沿用你原本的 FFE0/FFE1）
============================= */
let device, server, uartService, tx, rx;
const SERVICE_UUID = "0000ffe0-0000-1000-8000-00805f9b34fb";
const CHAR_UUID    = "0000ffe1-0000-1000-8000-00805f9b34fb";

const connectBtn    = document.getElementById("connectBle");
const disconnectBtn = document.getElementById("disconnectBle");
const statusEl      = document.getElementById("status");
const logEl         = document.getElementById("log");

let speedIndex = 2;
const speedEl = document.getElementById("speed");
const speedLabelEl = document.getElementById("speedLabel");

let rxBuffer = "";

// Log helper
function logLine(s){
  const time = new Date().toLocaleTimeString();
  logEl.textContent += `[${time}] ${s}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

// UI：速度滑桿
speedEl.addEventListener("input", () => {
  speedIndex = Number(speedEl.value);
  speedLabelEl.textContent = String(speedIndex);
  saveBlocks(); // 把目前速度也一併保存（可選）
});

// 寫入（20 bytes 分包）
async function writeLine(str){
  if(!tx){
    alert("請先連線 BLE");
    return;
  }
  const data = new TextEncoder().encode(str);
  const CHUNK = 20;
  for(let i=0;i<data.length;i+=CHUNK){
    await tx.writeValue(data.slice(i, i+CHUNK));
  }
  logLine(">>> " + JSON.stringify(str));
}

// 指令封裝
function cmdMove(cmd){ return cmd + String(speedIndex) + "\n"; }
function cmdUltra(cmd){ return cmd + String(speedIndex) + "\n"; }
function cmdGesture(cmd){ return cmd + "0\n"; } // 你的介面習慣表情固定 0

function onDisconnected(){
  tx = null; rx = null; uartService = null; server = null;
  statusEl.textContent = "尚未連線";
  connectBtn.disabled = false;
  disconnectBtn.disabled = true;
  setRunButtons();
  logLine("藍牙已斷線");
}

connectBtn.onclick = async () => {
  try{
    device = await navigator.bluetooth.requestDevice({
      filters: [{ namePrefix:"Otto" }, { namePrefix:"NFU" }],
      optionalServices: [SERVICE_UUID]
    });
    device.addEventListener("gattserverdisconnected", onDisconnected);

    server = await device.gatt.connect();
    uartService = await server.getPrimaryService(SERVICE_UUID);
    tx = await uartService.getCharacteristic(CHAR_UUID);
    rx = tx;

    await rx.startNotifications();
    rx.addEventListener("characteristicvaluechanged", handleNotify);

    statusEl.textContent = "已連線: " + (device.name || "(unknown)");
    connectBtn.disabled = true;
    disconnectBtn.disabled = false;
    setRunButtons();
    logLine("已連線，通知已開啟");
  }catch(e){
    alert("連線失敗: " + e);
    logLine("連線失敗: " + e);
  }
};

disconnectBtn.onclick = () => {
  try{
    if(rx) rx.removeEventListener("characteristicvaluechanged", handleNotify);
  }catch(_){}
  if(device && device.gatt && device.gatt.connected) device.gatt.disconnect();
  else onDisconnected();
};

// 解析回傳（保留擴充用）
function handleNotify(event){
  const chunk = new TextDecoder().decode(event.target.value);
  rxBuffer += chunk;
  let idx;
  while((idx = rxBuffer.indexOf("\n")) !== -1){
    const line = rxBuffer.slice(0, idx).trim();
    rxBuffer = rxBuffer.slice(idx+1);
    if(!line) continue;
    logLine("<<< " + line);
  }
  if(rxBuffer.length > 200) rxBuffer = rxBuffer.slice(-200);
}

/* =============================
   積木資料結構 + UI
============================= */
const blocksUl = document.getElementById("blocks");
const playBtn = document.getElementById("play");
const stopBtn = document.getElementById("stopRun");
const runnerStatusEl = document.getElementById("runnerStatus");

const blockTypeEl = document.getElementById("blockType");
const optMove = document.getElementById("optMove");
const optGesture = document.getElementById("optGesture");
const optSetSpeed = document.getElementById("optSetSpeed");
const optWait = document.getElementById("optWait");

const moveCmdEl = document.getElementById("moveCmd");
const moveMsEl = document.getElementById("moveMs");
const gestureCmdEl = document.getElementById("gestureCmd");
const setSpeedValEl = document.getElementById("setSpeedVal");
const waitSecEl = document.getElementById("waitSec");

let blocks = []; // {id, type, ...}
let running = false;
let abortFlag = false;

function uid(){
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}

function updateTypeOptions(){
  const t = blockTypeEl.value;
  optMove.style.display = (t==="move") ? "" : "none";
  optGesture.style.display = (t==="gesture") ? "" : "none";
  optSetSpeed.style.display = (t==="set_speed") ? "" : "none";
  optWait.style.display = (t==="wait") ? "" : "none";
}
blockTypeEl.addEventListener("change", updateTypeOptions);
updateTypeOptions();

function blockLabel(b){
  switch(b.type){
    case "move": return `移動：${b.cmd}（等 ${b.ms}ms）`;
    case "gesture": return `表情/動作：${b.cmd}`;
    case "ultra_once": return "超音波：量測一次 (ultrasound)";
    case "autoavoid_on": return "超音波：自動避障 ON";
    case "autoavoid_off": return "超音波：自動避障 OFF";
    case "stream_on": return "超音波：距離串流 ON";
    case "stream_off": return "超音波：距離串流 OFF";
    case "set_speed": return `設定速度：${b.val}`;
    case "wait": return `等待：${b.sec} 秒`;
    default: return b.type;
  }
}
function blockDesc(b){
  switch(b.type){
    case "move": return `送出 ${b.cmd + "{speed}"}，再等待 ${b.ms}ms（可用來做步態節奏）`;
    case "gesture": return `送出 ${b.cmd + "0"}（表情固定尾碼 0）`;
    case "ultra_once": return "送出 ultrasound{speed}，Arduino 回傳 US:xx";
    case "autoavoid_on": return "送出 autoavoid_on{speed}，Arduino 回傳 AUTOAVOID:ON";
    case "autoavoid_off": return "送出 autoavoid_off{speed}，Arduino 回傳 AUTOAVOID:OFF";
    case "stream_on": return "送出 us_stream_on{speed}，Arduino 回傳 US_STREAM:ON";
    case "stream_off": return "送出 us_stream_off{speed}，Arduino 回傳 US_STREAM:OFF";
    case "set_speed": return "只改變流程內的速度檔位，不會立刻送指令";
    case "wait": return "純等待，不送指令（常用在動作之間）";
    default: return "";
  }
}

function renderBlocks(){
  blocksUl.innerHTML = "";
  blocks.forEach((b, idx) => {
    const li = document.createElement("li");
    li.className = "block";
    li.draggable = true;
    li.dataset.id = b.id;

    const handle = document.createElement("div");
    handle.className = "handle";
    handle.title = "拖拉排序";
    handle.textContent = "≡";

    const meta = document.createElement("div");
    meta.className = "meta";
    const title = document.createElement("div");
    title.className = "title";
    title.textContent = `${idx+1}. ${blockLabel(b)}`;
    const desc = document.createElement("div");
    desc.className = "desc";
    desc.textContent = blockDesc(b);
    meta.appendChild(title);
    meta.appendChild(desc);

    const actions = document.createElement("div");
    actions.className = "actions";

    const btnDel = document.createElement("button");
    btnDel.className = "red";
    btnDel.textContent = "刪除";
    btnDel.onclick = () => {
      blocks = blocks.filter(x => x.id !== b.id);
      renderBlocks();
      saveBlocks();
      setRunButtons();
    };

    actions.appendChild(btnDel);

    li.appendChild(handle);
    li.appendChild(meta);
    li.appendChild(actions);

    // 拖拉排序（原生 Drag & Drop）
    li.addEventListener("dragstart", (e) => {
      li.classList.add("dragging");
      e.dataTransfer.setData("text/plain", b.id);
      e.dataTransfer.effectAllowed = "move";
    });
    li.addEventListener("dragend", () => {
      li.classList.remove("dragging");
    });
    li.addEventListener("dragover", (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
    });
    li.addEventListener("drop", (e) => {
      e.preventDefault();
      const fromId = e.dataTransfer.getData("text/plain");
      const toId = b.id;
      if(!fromId || fromId === toId) return;
      const fromIdx = blocks.findIndex(x => x.id === fromId);
      const toIdx = blocks.findIndex(x => x.id === toId);
      if(fromIdx < 0 || toIdx < 0) return;

      const item = blocks.splice(fromIdx, 1)[0];
      blocks.splice(toIdx, 0, item);
      renderBlocks();
      saveBlocks();
    });

    blocksUl.appendChild(li);
  });
}

document.getElementById("addBlock").onclick = () => {
  const t = blockTypeEl.value;
  const b = { id: uid(), type: t };

  if(t === "move"){
    b.cmd = moveCmdEl.value;
    b.ms = Math.max(0, Number(moveMsEl.value || 0));
  }else if(t === "gesture"){
    b.cmd = (gestureCmdEl.value || "happy").trim();
  }else if(t === "set_speed"){
    let v = Number(setSpeedValEl.value);
    if(Number.isNaN(v)) v = 2;
    b.val = Math.min(5, Math.max(0, Math.round(v)));
  }else if(t === "wait"){
    let s = Number(waitSecEl.value);
    if(Number.isNaN(s)) s = 1;
    b.sec = Math.max(0, s);
  }

  blocks.push(b);
  renderBlocks();
  saveBlocks();
  setRunButtons();
};

document.getElementById("clearBlocks").onclick = () => {
  blocks = [];
  renderBlocks();
  saveBlocks();
  setRunButtons();
};

document.getElementById("clearLog").onclick = () => {
  logEl.textContent = "";
};

function saveBlocks(){
  const payload = {
    speedIndex,
    blocks
  };
  localStorage.setItem("OTTO_BLOCKS_V1", JSON.stringify(payload));
}

function loadBlocks(){
  try{
    const s = localStorage.getItem("OTTO_BLOCKS_V1");
    if(!s) return;
    const obj = JSON.parse(s);
    if(typeof obj.speedIndex === "number"){
      speedIndex = obj.speedIndex;
      speedEl.value = String(speedIndex);
      speedLabelEl.textContent = String(speedIndex);
    }
    if(Array.isArray(obj.blocks)){
      blocks = obj.blocks;
    }
  }catch(_){}
}

function sleep(ms){
  return new Promise(res => setTimeout(res, ms));
}

function setRunButtons(){
  const connected = !!tx;
  playBtn.disabled = !(connected && blocks.length>0) || running;
  stopBtn.disabled = !running;
}

async function runBlocks(){
  if(!tx){
    alert("請先連線 BLE");
    return;
  }
  if(blocks.length === 0){
    alert("請先加入積木");
    return;
  }

  running = true;
  abortFlag = false;
  setRunButtons();
  runnerStatusEl.textContent = "流程：執行中";
  logLine("=== PLAY 開始 ===");

  // 用「流程內速度」：初始為目前 UI 的 speedIndex
  let flowSpeed = speedIndex;

  // 執行序列
  for(let i=0; i<blocks.length; i++){
    if(abortFlag) break;
    const b = blocks[i];
    runnerStatusEl.textContent = `流程：第 ${i+1}/${blocks.length} 個積木`;

    // 讓每步 log 更清楚
    logLine(`[STEP ${i+1}] ${blockLabel(b)}（speed=${flowSpeed}）`);

    try{
      if(b.type === "set_speed"){
        flowSpeed = b.val;
        // 同步 UI（可選）
        speedIndex = flowSpeed;
        speedEl.value = String(speedIndex);
        speedLabelEl.textContent = String(speedIndex);
        continue;
      }

      if(b.type === "wait"){
        await sleep(Math.round(b.sec * 1000));
        continue;
      }

      // 這裡把「流程速度」套入指令尾碼
      if(b.type === "move"){
        await writeLine(b.cmd + String(flowSpeed) + "\n");
        if(b.ms > 0) await sleep(b.ms);
        continue;
      }

      if(b.type === "gesture"){
        await writeLine(b.cmd + "0\n");
        // 可自行加一點緩衝
        await sleep(150);
        continue;
      }

      if(b.type === "ultra_once"){
        await writeLine("ultrasound" + String(flowSpeed) + "\n");
        await sleep(120);
        continue;
      }

      if(b.type === "autoavoid_on"){
        await writeLine("autoavoid_on" + String(flowSpeed) + "\n");
        await sleep(120);
        continue;
      }

      if(b.type === "autoavoid_off"){
        await writeLine("autoavoid_off" + String(flowSpeed) + "\n");
        await sleep(120);
        continue;
      }

      if(b.type === "stream_on"){
        await writeLine("us_stream_on" + String(flowSpeed) + "\n");
        await sleep(120);
        continue;
      }

      if(b.type === "stream_off"){
        await writeLine("us_stream_off" + String(flowSpeed) + "\n");
        await sleep(120);
        continue;
      }
    }catch(e){
      logLine("執行錯誤：" + e);
      break;
    }
  }

  if(abortFlag){
    logLine("=== STOP：流程已中止 ===");
    runnerStatusEl.textContent = "流程：已中止";
  }else{
    logLine("=== PLAY 結束 ===");
    runnerStatusEl.textContent = "流程：完成";
  }

  running = false;
  setRunButtons();
  saveBlocks();
}

playBtn.onclick = () => runBlocks();
stopBtn.onclick = async () => {
  abortFlag = true;

  // 你也可以選擇中止時送一個 stop（用當前 UI 速度）
  try{
    if(tx){
      await writeLine("stop" + String(speedIndex) + "\n");
    }
  }catch(_){}

  setRunButtons();
};

function bootstrap(){
  loadBlocks();
  renderBlocks();
  setRunButtons();
}
bootstrap();
</script>
</body>
</html>
